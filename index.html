<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulaire ÌïúÍµ≠Ïñ¥</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text x='50' y='70' font-family='Arial, sans-serif' font-size='70' font-weight='bold' fill='%23d4c5e2' text-anchor='middle'>Ìïú</text></svg>" type="image/svg+xml">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #faf8f3;
            --bg-secondary: #f5f0e8;
            --text-primary: #4a4a4a;
            --text-secondary: #7a7a7a;
            --text-light: #a89fb5;
            --accent: #c2a8d0;
            --accent-light: #d4c5e2;
            --white: #ffffff;
            --border: #e8e0f0;
            --success: #90d090;
            --success-bg: #d4f0d4;
            --error: #d09090;
            --error-bg: #f0d4d4;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-light: #808080;
            --accent: #b89fcf;
            --accent-light: #9d8bc0;
            --white: #2d2d2d;
            --border: #404040;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
        }

        .header-top {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        h1 {
            font-size: 2em;
            color: var(--accent);
            font-weight: 300;
            letter-spacing: 2px;
        }

        .dark-mode-toggle {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            transition: transform 0.3s;
            padding: 5px 10px;
        }

        .dark-mode-toggle:hover {
            transform: scale(1.1);
        }

        .subtitle {
            color: var(--text-light);
            font-size: 0.9em;
        }

        #wordCounter {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-light);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .user-badge {
            background: var(--accent-light);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            background: var(--white);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .tab-btn:hover {
            transform: translateY(-2px);
        }

        .tab-btn.active {
            background: var(--accent-light);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .form-section {
            background: var(--white);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            margin-bottom: 25px;
        }

        .form-group {
            margin-bottom: 18px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.95em;
        }

        select, input[type="text"], input[type="password"], textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-family: inherit;
            font-size: 1em;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: var(--accent-light);
            background: var(--white);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 11px 22px;
            border: none;
            border-radius: 10px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-primary {
            background: var(--accent-light);
            color: white;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            background: var(--accent-light);
            color: white;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        h2 {
            margin-bottom: 15px;
            color: var(--text-secondary);
            font-size: 1.3em;
        }

        h3 {
            margin-bottom: 12px;
            color: var(--text-secondary);
            font-size: 1.1em;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .game-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--border) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent-light);
            box-shadow: 0 8px 20px rgba(212, 197, 226, 0.3);
        }

        .game-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .game-title {
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .game-desc {
            font-size: 0.8em;
            color: var(--text-light);
        }

        .quiz-container {
            background: var(--white);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            text-align: center;
        }

        .quiz-word {
            font-size: 2em;
            color: var(--accent);
            margin-bottom: 25px;
            font-weight: 600;
        }

        .quiz-type {
            font-size: 0.9em;
            color: var(--text-light);
            margin-bottom: 15px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 25px;
        }

        .quiz-option {
            padding: 15px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            color: var(--text-primary);
        }

        .quiz-option:hover {
            border-color: var(--accent-light);
            background: var(--white);
        }

        .quiz-option.correct {
            background: var(--success-bg);
            border-color: var(--success);
            color: #2d7a2d;
        }

        .quiz-option.incorrect {
            background: var(--error-bg);
            border-color: var(--error);
            color: #8a5a5a;
        }

        .writing-input {
            font-size: 1.2em;
            padding: 15px !important;
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Noto Sans KR', monospace;
        }

        .writing-feedback {
            font-size: 1.1em;
            margin-bottom: 15px;
            min-height: 30px;
        }

        .writing-feedback.correct {
            color: #2d7a2d;
        }

        .writing-feedback.incorrect {
            color: #8a5a5a;
        }

        .flashcard {
            width: 100%;
            max-width: 400px;
            height: 250px;
            margin: 0 auto 30px;
            perspective: 1000px;
            cursor: pointer;
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            font-size: 2em;
            font-weight: 600;
        }

        .flashcard-front {
            background: linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 100%);
            color: white;
        }

        .flashcard-back {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--border) 100%);
            color: var(--accent);
            transform: rotateY(180deg);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 30px 0;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .memory-card {
            aspect-ratio: 1;
            background: linear-gradient(135deg, var(--accent-light), var(--accent));
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 600;
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .memory-card:hover:not(.matched) {
            transform: scale(1.05);
        }

        .memory-card.flipped {
            background: linear-gradient(135deg, var(--bg-secondary), var(--border));
            color: var(--accent);
        }

        .memory-card.matched {
            background: var(--success-bg);
            color: #2d7a2d;
            cursor: default;
        }

        .vocab-list {
            display: grid;
            gap: 12px;
        }

        .vocab-card {
            background: var(--white);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border-left: 4px solid var(--accent-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vocab-korean {
            font-size: 1.2em;
            color: var(--accent);
            font-weight: 600;
        }

        .vocab-french {
            font-size: 0.95em;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .vocab-meta {
            font-size: 0.75em;
            color: var(--text-light);
            margin-top: 5px;
        }

        .filter-section {
            margin-bottom: 18px;
        }

        .empty-message {
            text-align: center;
            color: var(--text-light);
            padding: 30px 20px;
            font-size: 1em;
        }

        .stats {
            background: var(--bg-secondary);
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            color: var(--text-secondary);
            text-align: center;
            font-size: 0.95em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: var(--white);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .stat-number {
            font-size: 1.8em;
            color: var(--accent);
            font-weight: 600;
        }

        .stat-label {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .chart-container {
            background: var(--white);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-light);
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .admin-table {
            background: var(--white);
            border-radius: 10px;
            overflow-x: auto;
            margin-top: 15px;
        }

        .admin-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .admin-table th {
            background: var(--accent-light);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 500;
        }

        .admin-table td {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            color: var(--text-primary);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-light);
            transition: width 0.3s ease;
        }

        .alert {
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .alert-success {
            background: var(--success-bg);
            color: #2d7a2d;
            border-left: 4px solid var(--success);
        }

        .alert-error {
            background: var(--error-bg);
            color: #8a5a5a;
            border-left: 4px solid var(--error);
        }

        .alert-info {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-left: 4px solid var(--accent-light);
        }

/* ========== NOUVEAU: Radio buttons pour modes ========== */
.mode-selector {
    background: var(--bg-secondary);
    padding: 18px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.mode-selector-title {
    font-size: 0.9em;
    color: var(--text-secondary);
    margin-bottom: 12px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 8px;
}

.mode-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.mode-option {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    background: var(--white);
    border: 2px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.mode-option:hover {
    border-color: var(--accent-light);
    background: var(--bg-primary);
}

.mode-option.selected {
    border-color: var(--accent);
    background: linear-gradient(135deg, rgba(212, 197, 226, 0.1) 0%, rgba(194, 168, 208, 0.1) 100%);
}

.mode-option input[type="radio"] {
    margin: 0;
    margin-right: 10px;
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: var(--accent);
}

.mode-label {
    flex: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
}

.mode-info {
    display: flex;
    align-items: center;
    gap: 8px;
}

.mode-emoji {
    font-size: 1.2em;
}

.mode-name {
    font-weight: 500;
    font-size: 0.9em;
    color: var(--text-primary);
}

.mode-option.selected .mode-name {
    color: var(--accent);
    font-weight: 600;
}

.mode-count {
    font-size: 0.8em;
    color: var(--text-light);
    background: var(--bg-secondary);
    padding: 3px 10px;
    border-radius: 12px;
    font-weight: 500;
}

.mode-option.selected .mode-count {
    background: var(--accent-light);
    color: white;
}

.mode-note {
    font-size: 0.8em;
    color: var(--text-light);
    margin-top: 8px;
    font-style: italic;
}
/* ========== FIN NOUVEAU CSS ========== */

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
            }

            .form-section {
                padding: 18px;
            }

            .games-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .quiz-options {
                grid-template-columns: 1fr;
            }

            .memory-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .vocab-card {
                flex-direction: column;
                align-items: flex-start;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }


    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <h1>ÌïúÍµ≠Ïñ¥</h1>
                <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="Mode sombre">üåô</button>
            </div>
            <p class="subtitle">Vocabulaire Cor√©en</p>
            <div id="wordCounter">
                <span id="totalWordCount">0</span> mots en base
            </div>
            <div class="user-info" id="userInfo"></div>
        </header>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('jeux')">üéÆ Jeux</button>
            <button class="tab-btn" onclick="switchTab('vocab')">üìö Vocabulaire</button>
            <button class="tab-btn" onclick="switchTab('compte')">üë§ Mon Compte</button>
            <button class="tab-btn" onclick="switchTab('admin')">üîê Admin</button>
        </div>

        <!-- TAB JEUX -->
        <div id="jeux" class="tab-content active">

            <div class="form-section">
    <h2>üéÆ Choisir un jeu</h2>
    
    <!-- √âTAPE 1 : Cat√©gorie -->
    <div class="filter-section">
        <label for="gameCategory">üìÇ Cat√©gorie</label>
        <select id="gameCategory" onchange="updateModeCounts()">
            <option value="">Toutes les cat√©gories</option>
            <option value="G√©n√©ral">G√©n√©ral</option>
            <option value="Famille">Famille</option>
            <option value="M√©tiers">M√©tiers</option>
            <option value="Nourriture">Nourriture</option>
            <option value="Sports">Sports</option>
            <option value="V√™tements">V√™tements</option>
            <option value="Verbes">Verbes</option>
            <option value="Adjectifs">Adjectifs</option>
        </select>
    </div>

    <!-- √âTAPE 2 : Mode de r√©vision (NOUVEAU) -->
    <div class="mode-selector">
        <div class="mode-selector-title">
            ‚öôÔ∏è Mode de r√©vision
        </div>
        <div class="mode-options">
            <label class="mode-option selected" data-mode="all">
                <input type="radio" name="sessionMode" value="all" checked onclick="selectMode('all')">
                <div class="mode-label">
                    <div class="mode-info">
                        <span class="mode-emoji">üåç</span>
                        <span class="mode-name">Tous les mots</span>
                    </div>
                    <span class="mode-count" id="modeCountAll">-</span>
                </div>
            </label>
            
            <label class="mode-option" data-mode="new">
                <input type="radio" name="sessionMode" value="new" onclick="selectMode('new')">
                <div class="mode-label">
                    <div class="mode-info">
                        <span class="mode-emoji">‚ú®</span>
                        <span class="mode-name">Nouveaux mots</span>
                    </div>
                    <span class="mode-count" id="modeCountNew">-</span>
                </div>
            </label>
            
            <label class="mode-option" data-mode="review">
                <input type="radio" name="sessionMode" value="review" onclick="selectMode('review')">
                <div class="mode-label">
                    <div class="mode-info">
                        <span class="mode-emoji">üîÑ</span>
                        <span class="mode-name">R√©vision</span>
                    </div>
                    <span class="mode-count" id="modeCountReview">-</span>
                </div>
            </label>
            
            <label class="mode-option" data-mode="difficult">
                <input type="radio" name="sessionMode" value="difficult" onclick="selectMode('difficult')">
                <div class="mode-label">
                    <div class="mode-info">
                        <span class="mode-emoji">üéØ</span>
                        <span class="mode-name">Mots difficiles</span>
                    </div>
                    <span class="mode-count" id="modeCountDifficult">-</span>
                </div>
            </label>
        </div>
        <div class="mode-note">
            üí° Chaque session contient maximum 10-15 mots
        </div>
    </div>

    <!-- √âTAPE 3 : Jeux -->
    <div class="games-grid">
        <button class="game-card" onclick="startGame('quiz')">
            <div class="game-icon">‚ùì</div>
            <div class="game-title">Quiz</div>
            <div class="game-desc">Choisis la r√©ponse</div>
        </button>
        <button class="game-card" onclick="startGame('quiz-inverse')">
            <div class="game-icon">üîÑ</div>
            <div class="game-title">Quiz Inverse</div>
            <div class="game-desc">Cor√©en ‚Üí Fran√ßais</div>
        </button>
        <button class="game-card" onclick="startGame('cartes')">
            <div class="game-icon">üÉè</div>
            <div class="game-title">Cartes</div>
            <div class="game-desc">Flashcards</div>
        </button>
        <button class="game-card" onclick="startGame('memory')">
            <div class="game-icon">üß†</div>
            <div class="game-title">M√©mory</div>
            <div class="game-desc">Trouve les paires</div>
        </button>
        <button class="game-card" onclick="startGame('ecriture')">
            <div class="game-icon">‚úçÔ∏è</div>
            <div class="game-title">√âcriture</div>
            <div class="game-desc">Tape le cor√©en</div>
        </button>
    </div>
</div>

            <div id="gameContainer" style="display: none;"></div>
        </div>

        <!-- TAB VOCABULAIRE -->
        <div id="vocab" class="tab-content">
            <div class="form-section">
                <h2>Ajouter des mots</h2>
                
                <div class="form-group">
                    <label for="userName">Ton nom (optionnel)</label>
                    <input type="text" id="userName" placeholder="Laisse vide pour anonyme">
                </div>

                <div class="form-group">
                    <label for="category">Cat√©gorie</label>
                    <select id="category">
                        <option value="G√©n√©ral">G√©n√©ral</option>
                        <option value="Famille">Famille</option>
                        <option value="M√©tiers">M√©tiers</option>
                        <option value="Nourriture">Nourriture</option>
                        <option value="Sports">Sports</option>
                        <option value="V√™tements">V√™tements</option>
                        <option value="Verbes">Verbes</option>
                        <option value="Adjectifs">Adjectifs</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="newWords">Format: cor√©en, fran√ßais</label>
                    <textarea id="newWords" placeholder="ÌôçÏ∞®, th√© noir&#10;Î™®Ïûê, chapeau"></textarea>
                </div>

                <div class="button-group">
                    <button class="btn-primary" onclick="addWords()">+ Ajouter</button>
                </div>
            </div>

            <div class="form-section">
                <h2>Tous les mots</h2>
                
                <div class="filter-section">
                    <label for="filterCategory">Filtrer</label>
                    <select id="filterCategory" onchange="displayVocab()">
                        <option value="">Toutes les cat√©gories</option>
                        <option value="G√©n√©ral">G√©n√©ral</option>
                        <option value="Famille">Famille</option>
                        <option value="M√©tiers">M√©tiers</option>
                        <option value="Nourriture">Nourriture</option>
                        <option value="Sports">Sports</option>
                        <option value="V√™tements">V√™tements</option>
                        <option value="Verbes">Verbes</option>
                        <option value="Adjectifs">Adjectifs</option>
                    </select>
                </div>

                <div class="stats" id="stats"></div>
                <div id="vocabList" class="vocab-list">
                    <div style="text-align: center; padding: 20px;"><span class="loading"></span></div>
                </div>
            </div>
        </div>

        <!-- TAB MON COMPTE -->
        <div id="compte" class="tab-content">
            <!-- Section Login/Register -->
            <div id="authSection" class="form-section">
                <h2>Se connecter ou cr√©er un compte</h2>
                <div class="alert alert-info">
                    Cr√©e un compte pour sauvegarder tes statistiques et progresser ! üöÄ
                </div>

                <div class="form-group">
                    <label for="authUsername">Pseudo</label>
                    <input type="text" id="authUsername" placeholder="Ton pseudo">
                </div>

                <div class="form-group">
                    <label for="authPassword">Mot de passe</label>
                    <input type="password" id="authPassword" placeholder="Minimum 6 caract√®res">
                </div>

                <div class="button-group">
                    <button class="btn-primary" onclick="loginUser()">Se connecter</button>
                    <button class="btn-secondary" onclick="registerUser()">Cr√©er un compte</button>
                </div>

                <div id="authMessage" style="margin-top: 15px;"></div>
            </div>

            <!-- Section Profil (cach√© par d√©faut) -->
            <div id="profileSection" style="display: none;">
                <div class="form-section">
                    <h2>Mon Profil</h2>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <div style="font-size: 1.2em; font-weight: 600; color: var(--accent); margin-bottom: 5px;" id="profileUsername"></div>
                            <div style="font-size: 0.85em; color: var(--text-light);" id="profileJoinDate"></div>
                        </div>
                        <button class="btn-secondary" onclick="logoutUser()">D√©connexion</button>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-number" id="userTotalSessions">0</div>
                            <div class="stat-label">Sessions</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="userTotalGames">0</div>
                            <div class="stat-label">Jeux jou√©s</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="userSuccessRate">0%</div>
                            <div class="stat-label">Taux de r√©ussite</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="userStreak">0</div>
                            <div class="stat-label">Jours d'affil√©e</div>
                        </div>
                    </div>

                    <h3>üìä Statistiques Globales</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px;">
                        <div class="stat-box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <div class="stat-number" id="totalWordsLearned">-</div>
                            <div class="stat-label" style="color: rgba(255,255,255,0.9);">Mots Appris</div>
                        </div>
                        <div class="stat-box" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                            <div class="stat-number" id="globalSuccessRate">-</div>
                            <div class="stat-label" style="color: rgba(255,255,255,0.9);">Taux de R√©ussite Global</div>
                        </div>
                    </div>

                    <h3>üí° Recommandations de R√©vision</h3>
                    <div id="recommendationsList" style="margin-bottom: 25px; padding: 15px; background: var(--bg-secondary); border-radius: 10px; min-height: 80px;">
                        <p style="color: var(--text-secondary); font-style: italic; margin: 0;">Analyse de vos faiblesses en cours...</p>
                    </div>

                    <h3>Progression par cat√©gorie</h3>
                    <div id="categoryProgress"></div>

                    <h3 style="margin-top: 25px;">Historique r√©cent</h3>
                    <div id="recentActivity"></div>
                </div>
            </div>
        </div>

        <!-- TAB ADMIN -->
        <div id="admin" class="tab-content">
            <div class="form-section">
                <h2>Acc√®s Admin</h2>
                <div id="adminLoginForm">
                    <div class="form-group">
                        <label for="adminPassword">Mot de passe admin</label>
                        <input type="password" id="adminPassword" placeholder="Rentre le mot de passe">
                    </div>
                    <button class="btn-primary" onclick="loginAdmin()">Acc√©der</button>
                </div>

                <div id="adminPanel" style="display: none;">
                    <h3 style="color: var(--text-secondary); margin-bottom: 15px;">üìä Dashboard Admin</h3>
                    
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-number" id="adminTotalWords">0</div>
                            <div class="stat-label">Mots</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="adminTotalUsers">0</div>
                            <div class="stat-label">Utilisateurs</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="adminActiveUsers">0</div>
                            <div class="stat-label">Actifs (7j)</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="adminTotalSessions">0</div>
                            <div class="stat-label">Sessions totales</div>
                        </div>
                    </div>

                    <div class="chart-container">
                        <h3>Activit√© des 7 derniers jours</h3>
                        <canvas id="activityChart"></canvas>
                    </div>

                    <div class="chart-container" style="max-width: 500px; margin: 0 auto;">
                        <h3>Jeux les plus populaires</h3>
                        <canvas id="gamesChart" style="max-height: 300px;"></canvas>
                    </div>

                    <div class="button-group">
                        <button class="btn-primary" onclick="exportAdminData()">üì• Exporter JSON</button>
                        <button class="btn-primary" onclick="exportStatsReport()">üìä Rapport Stats</button>
                        <button class="btn-danger" onclick="cleanInactiveUsers()">üóëÔ∏è Nettoyer inactifs</button>
                        <button class="btn-secondary" onclick="logoutAdmin()">D√©connexion</button>
                    </div>

                    <h3 style="margin-top: 25px;">Vocabulaire</h3>
                    <div class="form-group" style="margin-bottom: 15px; max-width: 300px;">
                        <label for="adminCategoryFilter">üîç Filtrer par cat√©gorie</label>
                        <select id="adminCategoryFilter" onchange="filterVocabByCategory()">
                            <option value="">üìã Toutes les cat√©gories</option>
                            <option value="G√©n√©ral">G√©n√©ral</option>
                            <option value="Famille">Famille</option>
                            <option value="M√©tiers">M√©tiers</option>
                            <option value="Nourriture">Nourriture</option>
                            <option value="Sports">Sports</option>
                            <option value="V√™tements">V√™tements</option>
                            <option value="Verbes">Verbes</option>
                            <option value="Adjectifs">Adjectifs</option>
                        </select>
                    </div>
                    <div class="admin-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Cor√©en</th>
                                    <th>Fran√ßais</th>
                                    <th>Cat√©gorie</th>
                                    <th>Par</th>
                                    <th>Date</th>
                                    <th style="width: 150px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="adminTableBody">
                                <tr><td colspan="6" style="text-align: center;"><span class="loading"></span></td></tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 style="margin-top: 25px;">Utilisateurs</h3>
                    <div class="admin-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Pseudo</th>
                                    <th>Sessions</th>
                                    <th>Derni√®re activit√©</th>
                                    <th>Membre depuis</th>
                                    <th style="width: 200px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="adminUsersTable">
                                <tr><td colspan="5" style="text-align: center;"><span class="loading"></span></td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://lkhcemzurtyyaqctdedb.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxraGNlbXp1cnR5eWFxY3RkZWRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE4MTcwMjgsImV4cCI6MjA3NzM5MzAyOH0.-BjUQu7NhRPQGKEyeDHowiWeU2cDgdUqlOeNmdy5Rgc';
        const ADMIN_PASSWORD = 'admin123';
        
        const { createClient } = supabase;
        const client = createClient(SUPABASE_URL, SUPABASE_KEY);

        let currentUser = null;
        let currentSession = null;
        let adminLoggedIn = false;
        let currentGame = null;
        let currentGameSet = [];
        let currentGameIndex = 0;
        let activityChart = null;
        let gamesChart = null;

        // ========== NOUVEAU: Variables de validation de session ==========
        let sessionStartTime = null;        // Timestamp de d√©but
        let questionsAnswered = 0;          // Nombre de questions r√©pondues
        let sessionValid = false;           // Session valide ou non
        let sessionInProgress = false;      // Indicateur de session active
        // ========== FIN NOUVEAU ==========

        // ========== NOUVEAU: Syst√®me de sessions progressives ==========
const SESSION_WORD_LIMIT = 15; // Limite de mots par session
let sessionMode = 'all'; // 'all', 'new', 'review', 'difficult'
let allVocabulary = []; // Cache du vocabulaire complet
// ========== FIN NOUVEAU ==========

        // ========== INITIALIZATION ==========
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
            const btn = document.querySelector('.dark-mode-toggle');
            btn.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
        }

        function loadDarkMode() {
            if (localStorage.getItem('darkMode') === 'true') {
                document.body.classList.add('dark-mode');
                document.querySelector('.dark-mode-toggle').textContent = '‚òÄÔ∏è';
            }
        }

        async function init() {
            loadDarkMode();
            await checkUserSession();
            await displayVocab();
            await updateWordCounter();
            await updateModeCounts(); // ‚Üê AJOUTER CETTE LIGNE
            subscribeToChanges();
        }

        async function updateWordCounter() {
            const { data, error } = await client.from('vocabulary').select('id', { count: 'exact' });
            if (!error && data) {
                document.getElementById('totalWordCount').innerText = data.length;
            }
        }

        function subscribeToChanges() {
            client.channel('vocabulary-changes')
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'vocabulary' },
                    () => {
                        displayVocab();
                        updateWordCounter();
                        if (adminLoggedIn) loadAdminData();
                    }
                )
                .subscribe();
        }

        // ========== USER AUTHENTICATION ==========
        async function checkUserSession() {
            const savedUser = localStorage.getItem('koreanAppUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                updateUserUI();
                await loadUserStats();
            }
        }

        function updateUserUI() {
            const userInfo = document.getElementById('userInfo');
            if (currentUser) {
                userInfo.innerHTML = `
                    <span class="user-badge">üë§ ${currentUser.username}</span>
                `;
                document.getElementById('authSection').style.display = 'none';
                document.getElementById('profileSection').style.display = 'block';
                document.getElementById('profileUsername').textContent = currentUser.username;
                
                const joinDate = new Date(currentUser.created_at).toLocaleDateString('fr-FR', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                });
                document.getElementById('profileJoinDate').textContent = `Membre depuis le ${joinDate}`;
                
                // ========== AJOUT√â ==========
                updateModeCounts(); // Mettre √† jour les compteurs de mots difficiles
                // ========== FIN AJOUT ==========
            } else {
                userInfo.innerHTML = '<span style="color: var(--text-light);">Mode anonyme</span>';
                document.getElementById('authSection').style.display = 'block';
                document.getElementById('profileSection').style.display = 'none';
            }
        }

        async function registerUser() {
            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;
            const messageDiv = document.getElementById('authMessage');

            if (!username || username.length < 3) {
                messageDiv.innerHTML = '<div class="alert alert-error">Le pseudo doit faire au moins 3 caract√®res</div>';
                return;
            }

            if (!password || password.length < 6) {
                messageDiv.innerHTML = '<div class="alert alert-error">Le mot de passe doit faire au moins 6 caract√®res</div>';
                return;
            }

            // Check if username exists
            const { data: existing } = await client
                .from('users')
                .select('id')
                .eq('username', username)
                .single();

            if (existing) {
                messageDiv.innerHTML = '<div class="alert alert-error">Ce pseudo est d√©j√† pris</div>';
                return;
            }

            // Create user
            const { data, error } = await client
                .from('users')
                .insert([{ username, password }])
                .select()
                .single();

            if (error) {
                messageDiv.innerHTML = '<div class="alert alert-error">Erreur: ' + error.message + '</div>';
                return;
            }

            currentUser = data;
            localStorage.setItem('koreanAppUser', JSON.stringify(data));
            messageDiv.innerHTML = '<div class="alert alert-success">‚úÖ Compte cr√©√© avec succ√®s !</div>';
            
            setTimeout(() => {
                updateUserUI();
                messageDiv.innerHTML = '';
            }, 1500);
        }

        async function loginUser() {
            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;
            const messageDiv = document.getElementById('authMessage');

            if (!username || !password) {
                messageDiv.innerHTML = '<div class="alert alert-error">Remplis tous les champs</div>';
                return;
            }

            const { data, error } = await client
                .from('users')
                .select('*')
                .eq('username', username)
                .eq('password', password)
                .single();

            if (error || !data) {
                messageDiv.innerHTML = '<div class="alert alert-error">Pseudo ou mot de passe incorrect</div>';
                return;
            }

            currentUser = data;
            localStorage.setItem('koreanAppUser', JSON.stringify(data));
            messageDiv.innerHTML = '<div class="alert alert-success">‚úÖ Connexion r√©ussie !</div>';
            
            setTimeout(() => {
                updateUserUI();
                loadUserStats();
                messageDiv.innerHTML = '';
            }, 1000);
        }

        function logoutUser() {
            currentUser = null;
            localStorage.removeItem('koreanAppUser');
            updateUserUI();
            document.getElementById('authUsername').value = '';
            document.getElementById('authPassword').value = '';
        }

        // ========== USER STATS ==========
        async function loadUserStats() {
            if (!currentUser) return;

            // Load sessions
            const { data: sessions } = await client
                .from('user_sessions')
                .select('*')
                .eq('user_id', currentUser.id)
                .order('created_at', { ascending: false });

            document.getElementById('userTotalSessions').textContent = sessions?.length || 0;

            // Load game results
            const { data: results } = await client
                .from('game_results')
                .select('*')
                .eq('user_id', currentUser.id);

            document.getElementById('userTotalGames').textContent = results?.length || 0;

            if (results && results.length > 0) {
                const totalCorrect = results.reduce((sum, r) => sum + r.correct_answers, 0);
                const totalQuestions = results.reduce((sum, r) => sum + r.total_questions, 0);
                const successRate = totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) : 0;
                document.getElementById('userSuccessRate').textContent = successRate + '%';
                
                // ========== NOUVELLES STATISTIQUES GLOBALES ==========
                
                // 1. Nombre total de mots appris (mots avec au moins 1 bonne r√©ponse)
                const wordsLearned = await calculateWordsLearned(results);
                document.getElementById('totalWordsLearned').textContent = wordsLearned;
                
                // 2. Taux de r√©ussite global (d√©j√† calcul√© ci-dessus)
                document.getElementById('globalSuccessRate').textContent = successRate + '%';
                
                // 3. Recommandations bas√©es sur les faiblesses
                await generateRecommendations(results);
            } else {
                // Valeurs par d√©faut si aucun r√©sultat
                document.getElementById('totalWordsLearned').textContent = '0';
                document.getElementById('globalSuccessRate').textContent = '0%';
                document.getElementById('recommendationsList').innerHTML = '<p style="color: var(--text-secondary); font-style: italic; margin: 0;">Commence √† jouer pour recevoir des recommandations personnalis√©es ! üéÆ</p>';
            }

            // Calculate streak
            const streak = calculateStreak(sessions);
            document.getElementById('userStreak').textContent = streak;

            // Load progress by category
            await loadCategoryProgress();

            // Load recent activity
            await loadRecentActivity();
        }
        
        // ========== CALCUL DES MOTS APPRIS ==========
        async function calculateWordsLearned(results) {
            if (!results || results.length === 0) return 0;
            
            // Compter le nombre de mots uniques appris bas√© sur les cat√©gories jou√©es
            // et le taux de r√©ussite (estimation)
            const categoriesPlayed = new Set();
            let totalCorrect = 0;
            
            results.forEach(result => {
                if (result.category) {
                    categoriesPlayed.add(result.category);
                }
                totalCorrect += result.correct_answers || 0;
            });
            
            // Estimer le nombre de mots appris comme le nombre total de bonnes r√©ponses
            // divis√© par 2 (car un mot peut √™tre vu plusieurs fois)
            const estimatedWords = Math.max(1, Math.floor(totalCorrect / 2));
            
            return estimatedWords;
        }
        
        // ========== G√âN√âRATION DES RECOMMANDATIONS ==========
        async function generateRecommendations(results) {
            if (!results || results.length === 0) return;
            
            // Analyser les erreurs par cat√©gorie
            const categoryErrors = {};
            const wordErrors = {};
            
            results.forEach(result => {
                const category = result.category || 'Non cat√©goris√©';
                
                if (!categoryErrors[category]) {
                    categoryErrors[category] = {
                        correct: 0,
                        incorrect: 0,
                        total: 0
                    };
                }
                
                categoryErrors[category].correct += result.correct_answers || 0;
                categoryErrors[category].incorrect += (result.total_questions - result.correct_answers) || 0;
                categoryErrors[category].total += result.total_questions || 0;
                
                // Analyser les erreurs par mot si les d√©tails sont disponibles
                if (result.details && Array.isArray(result.details)) {
                    result.details.forEach(detail => {
                        if (!detail.correct && detail.word) {
                            const wordKey = detail.word.korean || detail.word;
                            wordErrors[wordKey] = (wordErrors[wordKey] || 0) + 1;
                        }
                    });
                }
            });
            
            // G√©n√©rer les recommandations
            let html = '';
            
            // 1. Cat√©gories √† travailler (taux de r√©ussite < 70%)
            const weakCategories = Object.entries(categoryErrors)
                .map(([cat, stats]) => ({
                    category: cat,
                    rate: (stats.correct / stats.total) * 100,
                    total: stats.total
                }))
                .filter(c => c.rate < 70 && c.total >= 5)
                .sort((a, b) => a.rate - b.rate);
            
            if (weakCategories.length > 0) {
                html += '<div style="margin-bottom: 15px;"><strong style="color: var(--accent);">üìö Cat√©gories √† r√©viser :</strong><ul style="margin: 8px 0 0 20px; color: var(--text-secondary);">';
                weakCategories.slice(0, 3).forEach(cat => {
                    html += `<li><strong>${cat.category}</strong> (${cat.rate.toFixed(0)}% de r√©ussite) - Utilise le mode "Mots difficiles" !</li>`;
                });
                html += '</ul></div>';
            }
            
            // 2. Mots les plus difficiles (erreurs r√©p√©t√©es)
            const difficultWords = Object.entries(wordErrors)
                .map(([word, errors]) => ({ word, errors }))
                .filter(w => w.errors >= 3)
                .sort((a, b) => b.errors - a.errors)
                .slice(0, 5);
            
            if (difficultWords.length > 0) {
                html += '<div style="margin-bottom: 15px;"><strong style="color: var(--accent);">üéØ Mots √† revoir en priorit√© :</strong><ul style="margin: 8px 0 0 20px; color: var(--text-secondary);">';
                difficultWords.forEach(w => {
                    html += `<li><strong>${w.word}</strong> (${w.errors} erreur${w.errors > 1 ? 's' : ''})</li>`;
                });
                html += '</ul></div>';
            }
            
            // 3. Encouragements et conseils
            const totalCorrect = results.reduce((sum, r) => sum + r.correct_answers, 0);
            const totalQuestions = results.reduce((sum, r) => sum + r.total_questions, 0);
            const globalRate = (totalCorrect / totalQuestions) * 100;
            
            if (globalRate >= 80) {
                html += '<div style="padding: 10px; background: var(--success-bg); border-radius: 8px; color: var(--text-primary);"><strong>üåü Excellent travail !</strong> Continue comme √ßa, tu ma√Ætrises tr√®s bien le vocabulaire !</div>';
            } else if (globalRate >= 60) {
                html += '<div style="padding: 10px; background: #fff9e6; border-radius: 8px; color: var(--text-primary);"><strong>üí™ Bon rythme !</strong> Continue de pratiquer r√©guli√®rement pour progresser encore plus.</div>';
            } else {
                html += '<div style="padding: 10px; background: var(--error-bg); border-radius: 8px; color: var(--text-primary);"><strong>üöÄ Ne l√¢che rien !</strong> La pratique r√©guli√®re est la cl√©. Concentre-toi sur les cat√©gories ci-dessus.</div>';
            }
            
            // Si aucune faiblesse d√©tect√©e
            if (html === '') {
                html = '<div style="padding: 10px; background: var(--success-bg); border-radius: 8px; color: var(--text-primary);"><strong>üéâ F√©licitations !</strong> Tu n\'as pas de faiblesses majeures d√©tect√©es. Continue √† t\'entra√Æner pour maintenir ton niveau !</div>';
            }
            
            document.getElementById('recommendationsList').innerHTML = html;
        }

        function calculateStreak(sessions) {
            if (!sessions || sessions.length === 0) return 0;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let streak = 0;
            let currentDate = new Date(today);

            const sessionDates = sessions.map(s => {
                const d = new Date(s.created_at);
                d.setHours(0, 0, 0, 0);
                return d.getTime();
            });

            const uniqueDates = [...new Set(sessionDates)].sort((a, b) => b - a);

            for (let i = 0; i < uniqueDates.length; i++) {
                if (uniqueDates[i] === currentDate.getTime()) {
                    streak++;
                    currentDate.setDate(currentDate.getDate() - 1);
                } else if (uniqueDates[i] < currentDate.getTime()) {
                    break;
                }
            }

            return streak;
        }

        async function loadCategoryProgress() {
            if (!currentUser) return;

            const { data: results } = await client
                .from('game_results')
                .select('category, correct_answers, total_questions')
                .eq('user_id', currentUser.id);

            if (!results || results.length === 0) {
                document.getElementById('categoryProgress').innerHTML = '<p class="empty-message">Aucune progression pour le moment</p>';
                return;
            }

            const categoryStats = {};
            results.forEach(r => {
                if (!categoryStats[r.category]) {
                    categoryStats[r.category] = { correct: 0, total: 0 };
                }
                categoryStats[r.category].correct += r.correct_answers;
                categoryStats[r.category].total += r.total_questions;
            });

            let html = '';
            for (const [category, stats] of Object.entries(categoryStats)) {
                const percentage = Math.round((stats.correct / stats.total) * 100);
                const displayCategory = category || 'G√©n√©ral';  // Remplacer null par "G√©n√©ral"
                html += `
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="font-weight: 500; color: var(--text-secondary);">${displayCategory}</span>
                            <span style="color: var(--accent);">${percentage}%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }

            document.getElementById('categoryProgress').innerHTML = html;
        }

        async function loadRecentActivity() {
            if (!currentUser) return;

            const { data: sessions } = await client
                .from('user_sessions')
                .select('*')
                .eq('user_id', currentUser.id)
                .order('created_at', { ascending: false })
                .limit(5);

            if (!sessions || sessions.length === 0) {
                document.getElementById('recentActivity').innerHTML = '<p class="empty-message">Aucune activit√© r√©cente</p>';
                return;
            }

            let html = '<div class="vocab-list">';
            sessions.forEach(session => {
                const date = new Date(session.created_at).toLocaleDateString('fr-FR', {
                    day: 'numeric',
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const duration = session.duration_seconds ? Math.round(session.duration_seconds / 60) : 0;
                html += `
                    <div class="vocab-card">
                        <div>
                            <div style="font-weight: 600; color: var(--accent);">Session de ${session.game_type}</div>
                            <div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 3px;">
                                ${session.category || 'Toutes cat√©gories'} ‚Ä¢ ${duration} min
                            </div>
                            <div style="font-size: 0.75em; color: var(--text-light); margin-top: 3px;">${date}</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            document.getElementById('recentActivity').innerHTML = html;
        }

        // ========== SESSION TRACKING ==========
        async function startSession(gameType, category) {
            if (!currentUser) return null;

            const { data, error } = await client
                .from('user_sessions')
                .insert([{
                    user_id: currentUser.id,
                    game_type: gameType,
                    category: category || null
                }])
                .select()
                .single();

            if (!error && data) {
                currentSession = data;
                // ========== NOUVEAU ==========
                sessionStartTime = Date.now();
                questionsAnswered = 0;
                sessionValid = false;
                sessionInProgress = true;
                // ========== FIN NOUVEAU ==========
                return data;
            }
            return null;
        }

        async function endSession() {
            if (!currentSession) return;

            // ========== NOUVEAU: Validation de session ==========
            const duration = Math.round((Date.now() - sessionStartTime) / 1000);
            const isValidSession = duration >= 5 && questionsAnswered >= 1;
            
            if (isValidSession) {
                // Session valide ‚Üí enregistrer normalement
                await client
                    .from('user_sessions')
                    .update({ duration_seconds: duration })
                    .eq('id', currentSession.id);
                
                console.log('‚úÖ Session valide enregistr√©e:', { duration, questionsAnswered });
            } else {
                // Session invalide ‚Üí supprimer de la base
                await client
                    .from('user_sessions')
                    .delete()
                    .eq('id', currentSession.id);
                
                console.log('‚ùå Session invalide supprim√©e:', { duration, questionsAnswered });
            }
            // ========== FIN NOUVEAU ==========

            currentSession = null;
            sessionInProgress = false;
            sessionStartTime = null;
            questionsAnswered = 0;
        }

        // ========== NOUVEAU: Messages dynamiques selon score ==========
        function getDynamicMessage(correctCount, totalQuestions) {
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            let emoji = '';
            let title = '';
            let message = '';
            
            if (percentage === 100) {
                emoji = 'üåü';
                title = 'PARFAIT !';
                message = 'Score parfait ! Tu ma√Ætrises compl√®tement le sujet !';
            } else if (percentage >= 90) {
                emoji = 'üéâ';
                title = 'Excellent !';
                message = 'Presque parfait ! Continue comme √ßa !';
            } else if (percentage >= 70) {
                emoji = 'üí™';
                title = 'Tr√®s bien !';
                message = 'Bonne ma√Ætrise ! Encore un petit effort !';
            } else if (percentage >= 50) {
                emoji = 'üëç';
                title = 'Pas mal !';
                message = 'Un peu de r√©vision et ce sera parfait !';
            } else {
                emoji = 'üìö';
                title = 'Continue !';
                message = 'R√©vise ces mots et retente ta chance !';
            }
            
            return { emoji, title, message, percentage };
        }
        // ========== FIN NOUVEAU ==========

        async function saveGameResult(gameType, category, correctAnswers, totalQuestions) {
            if (!currentUser) return;

            await client
                .from('game_results')
                .insert([{
                    user_id: currentUser.id,
                    session_id: currentSession?.id || null,
                    game_type: gameType,
                    category: category || null,
                    correct_answers: correctAnswers,
                    total_questions: totalQuestions
                }]);

            if (currentUser) {
                await loadUserStats();
            }
        }

        // ========== VOCABULARY ==========
        async function addWords() {
            const input = document.getElementById('newWords').value.trim();
            const category = document.getElementById('category').value;
            const userName = document.getElementById('userName').value.trim() || 
                            (currentUser ? currentUser.username : 'Anonyme');

            if (!input) {
                alert('Ajoute au moins un mot !');
                return;
            }

            const lines = input.split('\n').filter(line => line.trim());
            const wordsToAdd = [];

            lines.forEach(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length === 2) {
                    wordsToAdd.push({
                        korean: parts[0],
                        french: parts[1],
                        category: category,
                        added_by: userName
                    });
                }
            });

            if (wordsToAdd.length === 0) {
                alert('Format invalide ! Utilise: cor√©en, fran√ßais');
                return;
            }

            const { error } = await client.from('vocabulary').insert(wordsToAdd);

            if (error) {
                alert('‚ùå Erreur: ' + error.message);
            } else {
                document.getElementById('newWords').value = '';
                alert(`‚úÖ ${wordsToAdd.length} mot(s) ajout√©(s) !`);
            }
        }

        async function displayVocab() {
            const filter = document.getElementById('filterCategory').value;
            let query = client.from('vocabulary').select('*').order('created_at', { ascending: false });

            if (filter) {
                query = query.eq('category', filter);
            }

            const { data, error } = await query;

            if (error) return;

            const list = document.getElementById('vocabList');
            const stats = document.getElementById('stats');

            stats.innerHTML = `${data.length} mot${data.length > 1 ? 's' : ''}`;

            if (data.length === 0) {
                list.innerHTML = '<p class="empty-message">Aucun mot</p>';
                return;
            }

            list.innerHTML = data.map(item => {
                const date = new Date(item.created_at).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
                return `
                    <div class="vocab-card">
                        <div>
                            <div class="vocab-korean">${item.korean}</div>
                            <div class="vocab-french">${item.french}</div>
                            <div class="vocab-meta">${item.category} ‚Ä¢ ${item.added_by} ‚Ä¢ ${date}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

// ========== NOUVEAU: Gestion des modes de session ==========

/**
 * S√©lectionne un mode de r√©vision
 * @param {string} mode - 'all', 'new', 'review', ou 'difficult'
 */
function selectMode(mode) {
    sessionMode = mode;
    
    // Mise √† jour visuelle des radio buttons
    document.querySelectorAll('.mode-option').forEach(option => {
        option.classList.remove('selected');
    });
    document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
}

/**
 * Met √† jour les compteurs de mots pour chaque mode
 */
async function updateModeCounts() {
    const category = document.getElementById('gameCategory').value;
    let query = client.from('vocabulary').select('*');
    
    if (category) {
        query = query.eq('category', category);
    }
    
    const { data: vocab } = await query;
    if (!vocab) return;
    
    allVocabulary = vocab;
    
    // Tous les mots
    const allCount = Math.min(vocab.length, SESSION_WORD_LIMIT);
    document.getElementById('modeCountAll').textContent = `${allCount} mots`;
    
    // Nouveaux mots (ajout√©s dans les 7 derniers jours)
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const newWords = vocab.filter(w => new Date(w.created_at) >= sevenDaysAgo);
    const newCount = Math.min(newWords.length, SESSION_WORD_LIMIT);
    document.getElementById('modeCountNew').textContent = `${newCount} mots`;
    
    // Mots en r√©vision (vus mais pas r√©cents)
    const reviewWords = vocab.filter(w => new Date(w.created_at) < sevenDaysAgo);
    const reviewCount = Math.min(reviewWords.length, SESSION_WORD_LIMIT);
    document.getElementById('modeCountReview').textContent = `${reviewCount} mots`;
    
    // Mots difficiles (bas√© sur les erreurs de l'utilisateur)
    if (currentUser) {
        const difficultWords = await getDifficultWords(vocab);
        const difficultCount = Math.min(difficultWords.length, SESSION_WORD_LIMIT);
        document.getElementById('modeCountDifficult').textContent = `${difficultCount} mots`;
    } else {
        document.getElementById('modeCountDifficult').textContent = '0 mots';
    }
}

/**
 * Identifie les mots difficiles bas√©s sur les performances
 * @param {Array} vocabSet - Ensemble de vocabulaire
 * @returns {Array} - Mots des cat√©gories difficiles
 */
async function getDifficultWords(vocabSet) {
    if (!currentUser) return [];
    
    // R√©cup√©rer les r√©sultats de l'utilisateur
    const { data: results } = await client
        .from('game_results')
        .select('*')
        .eq('user_id', currentUser.id);
    
    if (!results || results.length === 0) return [];
    
    // Analyser les erreurs par cat√©gorie
    const categoryErrors = {};
    results.forEach(r => {
        const category = r.category || 'G√©n√©ral';
        if (!categoryErrors[category]) {
            categoryErrors[category] = { correct: 0, total: 0 };
        }
        categoryErrors[category].correct += r.correct_answers || 0;
        categoryErrors[category].total += r.total_questions || 0;
    });
    
    // Filtrer les cat√©gories avec faible taux de r√©ussite (< 70%)
    const difficultCategories = Object.entries(categoryErrors)
        .filter(([cat, stats]) => {
            const rate = stats.total > 0 ? (stats.correct / stats.total) : 1;
            return rate < 0.7;
        })
        .map(([cat]) => cat);
    
    return vocabSet.filter(w => difficultCategories.includes(w.category));
}

/**
 * R√©cup√®re les mots pour la session selon le mode s√©lectionn√©
 * @param {string} category - Cat√©gorie s√©lectionn√©e (optionnel)
 * @returns {Array} - Mots filtr√©s et limit√©s
 */
async function getWordsForSession(category) {
    let words = allVocabulary;
    
    // Filtrer par cat√©gorie si n√©cessaire
    if (category) {
        words = words.filter(w => w.category === category);
    }
    
    // Appliquer le mode de session
    switch(sessionMode) {
        case 'new':
            // Mots ajout√©s dans les 7 derniers jours
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            words = words.filter(w => new Date(w.created_at) >= sevenDaysAgo);
            break;
            
        case 'review':
            // Mots plus anciens que 7 jours
            const reviewDate = new Date();
            reviewDate.setDate(reviewDate.getDate() - 7);
            words = words.filter(w => new Date(w.created_at) < reviewDate);
            break;
            
        case 'difficult':
            // Mots difficiles bas√©s sur les performances
            words = await getDifficultWords(words);
            break;
            
        case 'all':
        default:
            // Tous les mots (d√©j√† filtr√© par cat√©gorie si n√©cessaire)
            break;
    }
    
    // M√©langer et limiter √† SESSION_WORD_LIMIT
    words = words.sort(() => Math.random() - 0.5);
    return words.slice(0, SESSION_WORD_LIMIT);
}

// ========== FIN NOUVELLES FONCTIONS ==========

        // ========== GAMES ==========
        async function startGame(gameType) {
            const category = document.getElementById('gameCategory').value;
            
            // ========== MODIFI√â: Utiliser getWordsForSession ==========
            const words = await getWordsForSession(category);

            if (words.length === 0) {
                alert('‚ùå Aucun mot disponible pour ce mode et cette cat√©gorie');
                return;
            }

            const shuffledData = words.sort(() => Math.random() - 0.5);
            // ========== FIN MODIFICATION ==========

            currentGame = gameType;
            currentGameSet = shuffledData;
            currentGameIndex = 0;

            window.memoryCards = null;
            window.memoryMatched = null;
            window.memoryFlipped = null;

            await startSession(gameType, category);

            document.querySelector('.games-grid').parentElement.style.display = 'none';
            const container = document.getElementById('gameContainer');
            container.style.display = 'block';

            if (gameType === 'quiz') showQuizQuestion();
            else if (gameType === 'quiz-inverse') showQuizInverseQuestion();
            else if (gameType === 'cartes') showFlashcard();
            else if (gameType === 'memory') showMemory();
            else if (gameType === 'ecriture') showWritingQuestion();
        }

        function resetGames() {
            // ========== NOUVEAU: Confirmation si session en cours ==========
            if (sessionInProgress && questionsAnswered > 0) {
                const confirmed = confirm(
                    '‚ö†Ô∏è Es-tu s√ªr de vouloir quitter ?\n\n' +
                    'Ta progression sera perdue.\n' +
                    `Questions r√©pondues : ${questionsAnswered}`
                );
                
                if (!confirmed) {
                    return; // L'utilisateur annule, on reste dans le jeu
                }
            }
            // ========== FIN NOUVEAU ==========
            
            if (currentSession) {
                endSession();
            }
            document.querySelector('.games-grid').parentElement.style.display = 'block';
            document.querySelector('.mode-selector').style.display = 'block';
            document.getElementById('gameContainer').style.display = 'none';
        }

        function showQuizQuestion() {
            const container = document.getElementById('gameContainer');
            if (currentGameIndex >= currentGameSet.length) {
                const correctCount = window.quizCorrectCount || 0;
                saveGameResult('quiz', document.getElementById('gameCategory').value, correctCount, currentGameSet.length);
                endSession();
                
                // ========== NOUVEAU: Message dynamique ==========
                const dynamicMsg = getDynamicMessage(correctCount, currentGameSet.length);

                container.innerHTML = `
                    <div class="quiz-container">
                        <div style="font-size: 2.5em; margin-bottom: 15px;">${dynamicMsg.emoji}</div>
                        <h2 style="color: var(--accent); margin-bottom: 10px;">${dynamicMsg.title}</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 1.1em;">${dynamicMsg.message}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 10px;">Score: ${correctCount}/${currentGameSet.length}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 25px;">Taux de r√©ussite: ${dynamicMsg.percentage}%</p>
                        <button class="btn-primary" onclick="resetGames()" style="width: 150px;">‚Üê Retour</button>
                    </div>
                `;
                // ========== FIN NOUVEAU ==========
                window.quizCorrectCount = 0;
                return;
            }

            if (currentGameIndex === 0) {
                window.quizCorrectCount = 0;
            }

            const current = currentGameSet[currentGameIndex];
            const options = [current.french];
            const otherVocab = currentGameSet.filter(v => v.id !== current.id);

            for (let i = 0; i < 3 && otherVocab.length > 0; i++) {
                const random = otherVocab.splice(Math.floor(Math.random() * otherVocab.length), 1)[0];
                options.push(random.french);
            }

            options.sort(() => Math.random() - 0.5);

            container.innerHTML = `
                <div class="quiz-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="quiz-type">Question ${currentGameIndex + 1}/${currentGameSet.length}</div>
                        <button class="btn-secondary" style="padding: 8px 16px; font-size: 0.9em;" onclick="resetGames()">‚Üê Retour</button>
                    </div>
                    <div class="quiz-word">${current.korean}</div>
                    <div class="quiz-options">
                        ${options.map((opt, idx) => `
                            <button class="quiz-option" onclick="checkQuizAnswer(${currentGameIndex}, ${idx})">${opt}</button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function checkQuizAnswer(questionIndex, selectedIdx) {
            // ========== NOUVEAU ==========
            questionsAnswered++;
            // ========== FIN NOUVEAU ==========
            const current = currentGameSet[questionIndex];
            const buttons = document.querySelectorAll('.quiz-option');
            
            const correctIdx = Array.from(buttons).findIndex(btn => btn.textContent === current.french);
            
            if (selectedIdx === correctIdx) {
                window.quizCorrectCount = (window.quizCorrectCount || 0) + 1;
            }
            
            buttons.forEach((btn, idx) => {
                if (idx === correctIdx) btn.classList.add('correct');
                if (idx === selectedIdx && selectedIdx !== correctIdx) btn.classList.add('incorrect');
                btn.disabled = true;
            });

            setTimeout(() => {
                currentGameIndex++;
                showQuizQuestion();
            }, 1000);
        }

        function showQuizInverseQuestion() {
            const container = document.getElementById('gameContainer');
            if (currentGameIndex >= currentGameSet.length) {
                const correctCount = window.quizInverseCorrectCount || 0;
                saveGameResult('quiz-inverse', document.getElementById('gameCategory').value, correctCount, currentGameSet.length);
                endSession();
                
                // ========== NOUVEAU: Message dynamique ==========
                const dynamicMsg = getDynamicMessage(correctCount, currentGameSet.length);

                container.innerHTML = `
                    <div class="quiz-container">
                        <div style="font-size: 2.5em; margin-bottom: 15px;">${dynamicMsg.emoji}</div>
                        <h2 style="color: var(--accent); margin-bottom: 10px;">${dynamicMsg.title}</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 1.1em;">${dynamicMsg.message}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 10px;">Score: ${correctCount}/${currentGameSet.length}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 25px;">Taux de r√©ussite: ${dynamicMsg.percentage}%</p>
                        <button class="btn-primary" onclick="resetGames()" style="width: 150px;">‚Üê Retour</button>
                    </div>
                `;
                // ========== FIN NOUVEAU ==========
                window.quizInverseCorrectCount = 0;
                return;
            }

            if (currentGameIndex === 0) {
                window.quizInverseCorrectCount = 0;
            }

            const current = currentGameSet[currentGameIndex];
            const options = [current.korean];
            const otherVocab = currentGameSet.filter(v => v.id !== current.id);

            for (let i = 0; i < 3 && otherVocab.length > 0; i++) {
                const random = otherVocab.splice(Math.floor(Math.random() * otherVocab.length), 1)[0];
                options.push(random.korean);
            }

            options.sort(() => Math.random() - 0.5);

            container.innerHTML = `
                <div class="quiz-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="quiz-type">Question ${currentGameIndex + 1}/${currentGameSet.length}</div>
                        <button class="btn-secondary" style="padding: 8px 16px; font-size: 0.9em;" onclick="resetGames()">‚Üê Retour</button>
                    </div>
                    <div class="quiz-word">${current.french}</div>
                    <div style="font-size: 0.9em; color: var(--text-light); margin-bottom: 15px;">Quel est le mot cor√©en ?</div>
                    <div class="quiz-options">
                        ${options.map((opt, idx) => `
                            <button class="quiz-option" onclick="checkQuizInverseAnswer(${currentGameIndex}, ${idx})">${opt}</button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function checkQuizInverseAnswer(questionIndex, selectedIdx) {
            // ========== NOUVEAU ==========
            questionsAnswered++;
            // ========== FIN NOUVEAU ==========
            const current = currentGameSet[questionIndex];
            const buttons = document.querySelectorAll('.quiz-option');
            
            const correctIdx = Array.from(buttons).findIndex(btn => btn.textContent === current.korean);
            
            if (selectedIdx === correctIdx) {
                window.quizInverseCorrectCount = (window.quizInverseCorrectCount || 0) + 1;
            }
            
            buttons.forEach((btn, idx) => {
                if (idx === correctIdx) btn.classList.add('correct');
                if (idx === selectedIdx && selectedIdx !== correctIdx) btn.classList.add('incorrect');
                btn.disabled = true;
            });

            setTimeout(() => {
                currentGameIndex++;
                showQuizInverseQuestion();
            }, 1000);
        }

        function showFlashcard() {
            const container = document.getElementById('gameContainer');
            if (currentGameIndex >= currentGameSet.length) {
                saveGameResult('cartes', document.getElementById('gameCategory').value, currentGameSet.length, currentGameSet.length);
                endSession();
                
                container.innerHTML = `
                    <div class="quiz-container">
                        <div style="font-size: 2.5em; margin-bottom: 15px;">‚ú®</div>
                        <h2 style="color: var(--accent);">Cartes termin√©es !</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 25px;">Bien jou√© !</p>
                        <button class="btn-primary" onclick="resetGames()" style="width: 150px;">‚Üê Retour</button>
                    </div>
                `;
                return;
            }

            const current = currentGameSet[currentGameIndex];
            container.innerHTML = `
                <div class="quiz-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="quiz-type">${currentGameIndex + 1}/${currentGameSet.length}</div>
                        <button class="btn-secondary" style="padding: 8px 16px; font-size: 0.9em;" onclick="resetGames()">‚Üê Retour</button>
                    </div>
                    <div class="flashcard" onclick="this.classList.toggle('flipped')">
                        <div class="flashcard-inner">
                            <div class="flashcard-front">${current.korean}</div>
                            <div class="flashcard-back">${current.french}</div>
                        </div>
                    </div>
                    <div class="button-group">
                        <button class="btn-primary" onclick="questionsAnswered++; currentGameIndex++; showFlashcard();">Suivant ‚Üí</button>
                    </div>
                </div>
            `;
        }

        function showMemory() {
            const container = document.getElementById('gameContainer');
            
            if (!window.memoryCards) {
                const memorySet = currentGameSet.slice(0, 6);
                const cards = [];
                memorySet.forEach(word => {
                    cards.push({ value: word.korean, id: word.id });
                    cards.push({ value: word.korean, id: word.id });
                });
                cards.sort(() => Math.random() - 0.5);
                window.memoryCards = cards;
                window.memoryMatched = [];
                window.memoryFlipped = [];
            }

            const cards = window.memoryCards;
            const matched = window.memoryMatched;
            const flipped = window.memoryFlipped;
            const totalPairs = cards.length / 2;
            const foundPairs = matched.length / 2;

            if (foundPairs === totalPairs && foundPairs > 0) {
                saveGameResult('memory', document.getElementById('gameCategory').value, totalPairs, totalPairs);
                endSession();
            }

            container.innerHTML = `
                <div class="quiz-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="quiz-type">M√©mory - ${foundPairs}/${totalPairs} paires trouv√©es</div>
                        <button class="btn-secondary" style="padding: 8px 16px; font-size: 0.9em;" onclick="resetGames()">‚Üê Retour</button>
                    </div>
                    <div class="memory-grid">
                        ${cards.map((card, idx) => `
                            <button class="memory-card ${matched.includes(idx) ? 'matched' : ''} ${flipped.includes(idx) ? 'flipped' : ''}" 
                                onclick="flipMemoryCard(${idx})" id="card-${idx}">
                                ${(matched.includes(idx) || flipped.includes(idx)) ? card.value : '?'}
                            </button>
                        `).join('')}
                    </div>
                    ${foundPairs === totalPairs ? `
                        <div style="margin-top: 20px; text-align: center;">
                            <div style="font-size: 2em; margin-bottom: 10px;">üéâ</div>
                            <p style="color: var(--text-secondary); margin-bottom: 15px;">Tu as trouv√© toutes les paires !</p>
                            <button class="btn-primary" onclick="resetGames()" style="width: 150px;">‚Üê Retour</button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function flipMemoryCard(idx) {
            const cards = window.memoryCards;
            const matched = window.memoryMatched;
            const flipped = window.memoryFlipped;

            if (matched.includes(idx) || flipped.includes(idx) || flipped.length >= 2) return;

            flipped.push(idx);
            showMemory();

            if (flipped.length === 2) {
                const card1 = cards[flipped[0]];
                const card2 = cards[flipped[1]];

                if (card1.value === card2.value && flipped[0] !== flipped[1]) {
                    // ========== NOUVEAU ========== 
                    questionsAnswered++;
                    // ========== FIN NOUVEAU ========== 
                    window.memoryMatched++;
                    card1.matched = true;
                    card2.matched = true;
                    matched.push(flipped[0]);
                    matched.push(flipped[1]);
                    window.memoryFlipped = [];
                    setTimeout(() => showMemory(), 500);
                } else {
                    setTimeout(() => {
                        window.memoryFlipped = [];
                        showMemory();
                    }, 1000);
                }
            }
        }

        function showWritingQuestion() {
            const container = document.getElementById('gameContainer');
            if (currentGameIndex >= currentGameSet.length) {
                const correctCount = window.writingCorrectCount || 0;
                saveGameResult('ecriture', document.getElementById('gameCategory').value, correctCount, currentGameSet.length);
                endSession();
                
                // ========== NOUVEAU: Message dynamique ==========
                const dynamicMsg = getDynamicMessage(correctCount, currentGameSet.length);

                container.innerHTML = `
                    <div class="quiz-container">
                        <div style="font-size: 2.5em; margin-bottom: 15px;">${dynamicMsg.emoji}</div>
                        <h2 style="color: var(--accent); margin-bottom: 10px;">${dynamicMsg.title}</h2>
                        <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 1.1em;">${dynamicMsg.message}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 10px;">Score: ${correctCount}/${currentGameSet.length}</p>
                        <p style="color: var(--text-secondary); margin-bottom: 25px;">Taux de r√©ussite: ${dynamicMsg.percentage}%</p>
                        <button class="btn-primary" onclick="resetGames()" style="width: 150px;">‚Üê Retour</button>
                    </div>
                `;
                // ========== FIN NOUVEAU ==========
                window.writingCorrectCount = 0;
                return;
            }

            if (currentGameIndex === 0) {
                window.writingCorrectCount = 0;
            }

            const current = currentGameSet[currentGameIndex];
            container.innerHTML = `
                <div class="quiz-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="quiz-type">√âcriture ${currentGameIndex + 1}/${currentGameSet.length}</div>
                        <button class="btn-secondary" style="padding: 8px 16px; font-size: 0.9em;" onclick="resetGames()">‚Üê Retour</button>
                    </div>
                    <div class="quiz-word">${current.french}</div>
                    <div style="font-size: 0.9em; color: var(--text-light); margin-bottom: 15px;">√âcris le mot en cor√©en</div>
                    <input type="text" id="writingInput" class="writing-input" placeholder="Tape ici..." onkeypress="if(event.key==='Enter') checkWritingAnswer()">
                    <div id="writingFeedback" class="writing-feedback"></div>
                    <div class="button-group">
                        <button class="btn-primary" onclick="checkWritingAnswer()">V√©rifier</button>
                        <button class="btn-secondary" onclick="skipWritingQuestion()">Passer</button>
                    </div>
                </div>
            `;
            document.getElementById('writingInput').focus();
        }

        function checkWritingAnswer() {
            const input = document.getElementById('writingInput').value.trim();
            if (!input) { return; }

            // ========== NOUVEAU ==========
            questionsAnswered++;
            // ========== FIN NOUVEAU ==========

            if (input === current.korean) {
                window.writingCorrectCount = (window.writingCorrectCount || 0) + 1;
                feedback.textContent = '‚úÖ Correct !';
                feedback.className = 'writing-feedback correct';
                setTimeout(() => {
                    currentGameIndex++;
                    showWritingQuestion();
                }, 1500);
            } else {
                feedback.textContent = `‚ùå Non, c'est "${current.korean}"`;
                feedback.className = 'writing-feedback incorrect';
            }
        }

        function skipWritingQuestion() {
            currentGameIndex++;
            showWritingQuestion();
        }

        // ========== ADMIN ==========
        function loginAdmin() {
            const pass = document.getElementById('adminPassword').value;
            if (pass === ADMIN_PASSWORD) {
                adminLoggedIn = true;
                document.getElementById('adminLoginForm').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'block';
                loadAdminData();
            } else {
                alert('‚ùå Mot de passe incorrect');
            }
        }

        function logoutAdmin() {
            adminLoggedIn = false;
            document.getElementById('adminLoginForm').style.display = 'block';
            document.getElementById('adminPanel').style.display = 'none';
            document.getElementById('adminPassword').value = '';
            
            if (activityChart) activityChart.destroy();
            if (gamesChart) gamesChart.destroy();
        }

        async function loadAdminData() {
            if (!adminLoggedIn) return;

            // Get selected category filter
            const categoryFilter = document.getElementById('adminCategoryFilter')?.value || '';

            // Load vocabulary stats with filter
            let vocabQuery = client.from('vocabulary').select('*');
            if (categoryFilter) {
                vocabQuery = vocabQuery.eq('category', categoryFilter);
            }
            const { data: vocab } = await vocabQuery.order('created_at', { ascending: false });
            
            // Update count with filtered results
            document.getElementById('adminTotalWords').innerText = vocab?.length || 0;

            // Load users stats
            const { data: users } = await client.from('users').select('*');
            document.getElementById('adminTotalUsers').innerText = users?.length || 0;

            // Load sessions
            const { data: sessions } = await client.from('user_sessions').select('*');
            document.getElementById('adminTotalSessions').innerText = sessions?.length || 0;

            // Active users (last 7 days)
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            const activeUsers = new Set(sessions?.filter(s => new Date(s.created_at) >= sevenDaysAgo).map(s => s.user_id));
            document.getElementById('adminActiveUsers').innerText = activeUsers.size;

            // Load vocabulary table
            const tbody = document.getElementById('adminTableBody');
            tbody.innerHTML = vocab?.map(item => {
                const date = new Date(item.created_at).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
                return `
                    <tr>
                        <td><strong>${item.korean}</strong></td>
                        <td>${item.french}</td>
                        <td>${item.category}</td>
                        <td>${item.added_by}</td>
                        <td>${date}</td>
                        <td>
                            <button class="btn-danger" style="padding: 5px 10px; font-size: 0.85em;" onclick="deleteVocabWord('${item.id}', '${item.korean}')">üóëÔ∏è Supprimer</button>
                        </td>
                    </tr>
                `;
            }).join('') || '<tr><td colspan="6" style="text-align: center;">Aucune donn√©e</td></tr>';

            // Load users table
            const usersTable = document.getElementById('adminUsersTable');
            const usersWithStats = await Promise.all((users || []).map(async (user) => {
                const userSessions = sessions?.filter(s => s.user_id === user.id) || [];
                const lastActivity = userSessions.length > 0 ? 
                    new Date(Math.max(...userSessions.map(s => new Date(s.created_at)))).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' }) : 
                    'Jamais';
                const joinDate = new Date(user.created_at).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
                
                return {
                    id: user.id,
                    username: user.username,
                    sessions: userSessions.length,
                    lastActivity,
                    joinDate
                };
            }));

            usersTable.innerHTML = usersWithStats.map(user => `
                <tr>
                    <td><strong>${user.username}</strong></td>
                    <td>${user.sessions}</td>
                    <td>${user.lastActivity}</td>
                    <td>${user.joinDate}</td>
                    <td>
                        <button class="btn-secondary" style="padding: 5px 10px; font-size: 0.85em; margin-right: 5px;" onclick="viewUserDetails('${user.id}')">üëÅÔ∏è Voir</button>
                        <button class="btn-danger" style="padding: 5px 10px; font-size: 0.85em;" onclick="deleteUser('${user.id}', '${user.username}')">üóëÔ∏è</button>
                    </td>
                </tr>
            `).join('') || '<tr><td colspan="5" style="text-align: center;">Aucun utilisateur</td></tr>';

            // Load charts
            await loadActivityChart(sessions);
            await loadGamesChart(sessions);
        }

        async function loadActivityChart(sessions) {
            const ctx = document.getElementById('activityChart');
            
            // Prepare data for last 7 days
            const labels = [];
            const data = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                date.setHours(0, 0, 0, 0);
                
                const dateStr = date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric' });
                labels.push(dateStr);
                
                const dayEnd = new Date(date);
                dayEnd.setHours(23, 59, 59, 999);
                
                const count = sessions?.filter(s => {
                    const sessionDate = new Date(s.created_at);
                    return sessionDate >= date && sessionDate <= dayEnd;
                }).length || 0;
                
                data.push(count);
            }

            if (activityChart) activityChart.destroy();

            activityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Sessions',
                        data: data,
                        borderColor: 'rgb(212, 197, 226)',
                        backgroundColor: 'rgba(212, 197, 226, 0.1)',
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        async function loadGamesChart(sessions) {
            const ctx = document.getElementById('gamesChart');
            
            const gameTypes = ['quiz', 'quiz-inverse', 'cartes', 'memory', 'ecriture'];
            const gameLabels = ['Quiz', 'Quiz Inverse', 'Cartes', 'M√©mory', '√âcriture'];
            const data = gameTypes.map(type => 
                sessions?.filter(s => s.game_type === type).length || 0
            );

            if (gamesChart) gamesChart.destroy();

            gamesChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: gameLabels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#9b59b6', // Quiz - Violet
                            '#3498db', // Quiz Inverse - Bleu
                            '#e74c3c', // Cartes - Rouge
                            '#f39c12', // M√©mory - Orange
                            '#2ecc71'  // √âcriture - Vert
                        ],
                        borderWidth: 3,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 13
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const value = data.datasets[0].data[i];
                                            return {
                                                text: `${label}: ${value}`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                hidden: false,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        async function exportAdminData() {
            const { data: vocab } = await client.from('vocabulary').select('*');
            const { data: users } = await client.from('users').select('*');
            const { data: sessions } = await client.from('user_sessions').select('*');
            const { data: results } = await client.from('game_results').select('*');

            const exportData = {
                vocabulary: vocab,
                users: users?.map(u => ({ ...u, password: undefined })), // Remove passwords
                sessions: sessions,
                results: results,
                exported_at: new Date().toISOString()
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `korean-vocab-full-export-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        async function exportStatsReport() {
            const { data: vocab } = await client.from('vocabulary').select('*');
            const { data: users } = await client.from('users').select('*');
            const { data: sessions } = await client.from('user_sessions').select('*');
            const { data: results } = await client.from('game_results').select('*');

            // Calculate stats
            const totalWords = vocab?.length || 0;
            const totalUsers = users?.length || 0;
            const totalSessions = sessions?.length || 0;
            
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            const activeUsers = new Set(sessions?.filter(s => new Date(s.created_at) >= sevenDaysAgo).map(s => s.user_id)).size;
            
            const avgSessionDuration = sessions?.reduce((sum, s) => sum + (s.duration_seconds || 0), 0) / sessions?.length || 0;
            
            const gameStats = {};
            sessions?.forEach(s => {
                gameStats[s.game_type] = (gameStats[s.game_type] || 0) + 1;
            });

            const totalCorrect = results?.reduce((sum, r) => sum + r.correct_answers, 0) || 0;
            const totalQuestions = results?.reduce((sum, r) => sum + r.total_questions, 0) || 0;
            const avgSuccessRate = totalQuestions > 0 ? ((totalCorrect / totalQuestions) * 100).toFixed(1) : 0;

            // Calculate category stats
            const categoryStats = {};
            vocab?.forEach(v => {
                categoryStats[v.category] = (categoryStats[v.category] || 0) + 1;
            });

            // Calculate engagement rate
            const engagementRate = totalUsers > 0 ? ((activeUsers / totalUsers) * 100).toFixed(1) : 0;

            // Calculate retention (users with 2+ sessions)
            const userSessionCounts = {};
            sessions?.forEach(s => {
                userSessionCounts[s.user_id] = (userSessionCounts[s.user_id] || 0) + 1;
            });
            const returningUsers = Object.values(userSessionCounts).filter(count => count >= 2).length;
            const retentionRate = totalUsers > 0 ? ((returningUsers / totalUsers) * 100).toFixed(1) : 0;

            // Top performers
            const userPerformance = {};
            results?.forEach(r => {
                if (!userPerformance[r.user_id]) {
                    userPerformance[r.user_id] = { correct: 0, total: 0 };
                }
                userPerformance[r.user_id].correct += r.correct_answers;
                userPerformance[r.user_id].total += r.total_questions;
            });

            const report = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   üìä RAPPORT COMPLET - Application Vocabulaire Cor√©en ÌïúÍµ≠Ïñ¥    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìÖ Date du rapport: ${new Date().toLocaleDateString('fr-FR', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
})}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìö VOCABULAIRE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Mots en base: ${totalWords}
  ‚Ä¢ Cat√©gories actives: ${Object.keys(categoryStats).length}

  üìã R√©partition par cat√©gorie:
${Object.entries(categoryStats)
    .sort((a, b) => b[1] - a[1])
    .map(([cat, count]) => `     - ${cat}: ${count} mots`)
    .join('\n')}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üë• UTILISATEURS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Total d'utilisateurs: ${totalUsers}
  ‚Ä¢ Actifs (7 derniers jours): ${activeUsers}
  ‚Ä¢ Taux d'engagement: ${engagementRate}%
  ‚Ä¢ Utilisateurs r√©currents: ${returningUsers}
  ‚Ä¢ Taux de r√©tention: ${retentionRate}%

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üéÆ ACTIVIT√â ET ENGAGEMENT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Sessions totales: ${totalSessions}
  ‚Ä¢ Sessions par utilisateur (moyenne): ${totalUsers > 0 ? (totalSessions / totalUsers).toFixed(1) : 0}
  ‚Ä¢ Dur√©e moyenne par session: ${Math.round(avgSessionDuration / 60)} minutes
  ‚Ä¢ Taux de r√©ussite moyen: ${avgSuccessRate}%
  ‚Ä¢ Questions r√©pondues: ${totalQuestions}
  ‚Ä¢ R√©ponses correctes: ${totalCorrect}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üèÜ JEUX LES PLUS POPULAIRES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${Object.entries(gameStats)
    .sort((a, b) => b[1] - a[1])
    .map(([game, count], idx) => {
        const percentage = totalSessions > 0 ? ((count / totalSessions) * 100).toFixed(1) : 0;
        const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£', '5Ô∏è‚É£'];
        return `  ${medals[idx] || 'üìä'} ${game}: ${count} sessions (${percentage}%)`;
    })
    .join('\n')}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä PERFORMANCES PAR CAT√âGORIE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
${(() => {
    const catPerf = {};
    results?.forEach(r => {
        if (r.category) {
            if (!catPerf[r.category]) catPerf[r.category] = { correct: 0, total: 0 };
            catPerf[r.category].correct += r.correct_answers;
            catPerf[r.category].total += r.total_questions;
        }
    });
    return Object.entries(catPerf)
        .sort((a, b) => {
            const rateA = a[1].total > 0 ? (a[1].correct / a[1].total) : 0;
            const rateB = b[1].total > 0 ? (b[1].correct / b[1].total) : 0;
            return rateB - rateA;
        })
        .map(([cat, perf]) => {
            const rate = perf.total > 0 ? ((perf.correct / perf.total) * 100).toFixed(1) : 0;
            return `  ‚Ä¢ ${cat}: ${rate}% de r√©ussite (${perf.correct}/${perf.total})`;
        })
        .join('\n') || '  Aucune donn√©e disponible';
})()}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìà ANALYSES ET INSIGHTS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

${activeUsers >= totalUsers * 0.7 ? '‚úÖ EXCELLENT: Taux d\'engagement sup√©rieur √† 70%' : ''}
${activeUsers >= totalUsers * 0.5 && activeUsers < totalUsers * 0.7 ? '‚ö†Ô∏è BON: Taux d\'engagement autour de 50-70%' : ''}
${activeUsers < totalUsers * 0.5 && totalUsers > 0 ? '‚ö†Ô∏è ATTENTION: Taux d\'engagement inf√©rieur √† 50% - envisager des notifications' : ''}

${avgSuccessRate >= 75 ? '‚úÖ EXCELLENT: Taux de r√©ussite sup√©rieur √† 75%' : ''}
${avgSuccessRate >= 60 && avgSuccessRate < 75 ? '‚úÖ BON: Taux de r√©ussite entre 60-75%' : ''}
${avgSuccessRate < 60 && totalQuestions > 0 ? '‚ö†Ô∏è ATTENTION: Taux de r√©ussite bas - vocabulaire peut-√™tre trop difficile' : ''}

${retentionRate >= 70 ? '‚úÖ EXCELLENT: Plus de 70% des utilisateurs reviennent' : ''}
${retentionRate >= 50 && retentionRate < 70 ? '‚úÖ BON: Environ 50-70% de r√©tention' : ''}
${retentionRate < 50 && totalUsers > 0 ? '‚ö†Ô∏è √Ä AM√âLIORER: Moins de 50% de r√©tention - gamification recommand√©e' : ''}

${totalSessions < totalUsers * 3 && totalUsers > 0 ? 'üí° SUGGESTION: Moyenne de sessions faible - promouvoir davantage l\'utilisation' : ''}
${avgSessionDuration / 60 < 3 && totalSessions > 0 ? 'üí° SUGGESTION: Sessions courtes - envisager du contenu plus engageant' : ''}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üéØ RECOMMANDATIONS STRAT√âGIQUES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Pour pr√©senter √† l'institut:

1. POINTS FORTS √Ä METTRE EN AVANT:
   ${engagementRate >= 70 ? '‚úì Excellent taux d\'engagement des √©tudiants' : ''}
   ${avgSuccessRate >= 70 ? '‚úì R√©sultats d\'apprentissage probants' : ''}
   ${retentionRate >= 60 ? '‚úì Forte fid√©lisation des utilisateurs' : ''}
   ${totalSessions >= 50 ? '‚úì Utilisation r√©guli√®re et intensive' : ''}

2. M√âTRIQUES CL√âS POUR LA PR√âSENTATION:
   ‚Ä¢ ${activeUsers} √©tudiants actifs sur ${totalUsers} (${engagementRate}%)
   ‚Ä¢ ${totalSessions} sessions d'apprentissage
   ‚Ä¢ ${avgSuccessRate}% de taux de r√©ussite moyen
   ‚Ä¢ ${Math.round(avgSessionDuration / 60)} minutes d'engagement moyen

3. B√âN√âFICES MESURABLES:
   ‚Ä¢ Apprentissage autonome et gamifi√©
   ‚Ä¢ Suivi personnalis√© de la progression
   ‚Ä¢ ${totalQuestions} questions pratiqu√©es
   ‚Ä¢ Engagement mesurable et quantifiable

4. PROCHAINES √âTAPES SUGG√âR√âES:
   ${totalUsers < 20 ? '‚Ä¢ D√©ployer aupr√®s de plus d\'√©tudiants' : ''}
   ${avgSuccessRate < 70 ? '‚Ä¢ Ajuster la difficult√© du vocabulaire' : ''}
   ‚Ä¢ Ajouter plus de cat√©gories th√©matiques
   ‚Ä¢ Impl√©menter la r√©p√©tition espac√©e
   ‚Ä¢ Cr√©er des d√©fis inter-√©tudiants

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üíº VALEUR AJOUT√âE POUR L'INSTITUT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Cette application d√©montre:
‚úì Innovation p√©dagogique avec gamification
‚úì Donn√©es d'apprentissage mesurables et exploitables
‚úì Engagement √©tudiant quantifiable
‚úì Outil d√©velopp√© par et pour les √©tudiants
‚úì Scalable pour d'autres langues/mati√®res

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìß Contact: [Ton email/contact]
üîó Application: [URL de l'app]
üìÖ P√©riode analys√©e: ${(() => {
    if (!sessions || sessions.length === 0) return 'Aucune donn√©e';
    const dates = sessions.map(s => new Date(s.created_at));
    const oldest = new Date(Math.min(...dates));
    const newest = new Date(Math.max(...dates));
    return `${oldest.toLocaleDateString('fr-FR')} - ${newest.toLocaleDateString('fr-FR')}`;
})()}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Rapport g√©n√©r√© automatiquement ‚Ä¢ Korean Vocab App v2.0
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            `.trim();

            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `rapport-complet-korean-vocab-${new Date().toISOString().split('T')[0]}.txt`;
            link.click();
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');

            if (tabName === 'compte' && currentUser) {
                loadUserStats();
            }
        }

        // ========== ADMIN MANAGEMENT FUNCTIONS ==========

        async function deleteUser(userId, username) {
            if (!confirm(`‚ö†Ô∏è Confirmer la suppression de l'utilisateur "${username}" ?\n\nCela supprimera aussi toutes ses sessions et r√©sultats.`)) {
                return;
            }

            const { error } = await client
                .from('users')
                .delete()
                .eq('id', userId);

            if (error) {
                alert('‚ùå Erreur lors de la suppression: ' + error.message);
            } else {
                alert('‚úÖ Utilisateur supprim√© avec succ√®s');
                loadAdminData();
            }
        }

        async function viewUserDetails(userId) {
            // Get user data
            const { data: user } = await client.from('users').select('*').eq('id', userId).single();
            const { data: sessions } = await client.from('user_sessions').select('*').eq('user_id', userId).order('created_at', { ascending: false });
            const { data: results } = await client.from('game_results').select('*').eq('user_id', userId);

            if (!user) {
                alert('‚ùå Utilisateur introuvable');
                return;
            }

            // Calculate stats
            const totalSessions = sessions?.length || 0;
            const totalGames = results?.length || 0;
            const totalCorrect = results?.reduce((sum, r) => sum + r.correct_answers, 0) || 0;
            const totalQuestions = results?.reduce((sum, r) => sum + r.total_questions, 0) || 0;
            const successRate = totalQuestions > 0 ? ((totalCorrect / totalQuestions) * 100).toFixed(1) : 0;

            // Game breakdown
            const gameBreakdown = {};
            sessions?.forEach(s => {
                gameBreakdown[s.game_type] = (gameBreakdown[s.game_type] || 0) + 1;
            });

            let details = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üë§ D√âTAILS UTILISATEUR                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìã INFORMATIONS
  ‚Ä¢ Pseudo: ${user.username}
  ‚Ä¢ ID: ${user.id}
  ‚Ä¢ Membre depuis: ${new Date(user.created_at).toLocaleDateString('fr-FR', { dateStyle: 'long' })}
  ‚Ä¢ Derni√®re connexion: ${new Date(user.last_login).toLocaleDateString('fr-FR', { dateStyle: 'long' })}

üìä STATISTIQUES
  ‚Ä¢ Sessions totales: ${totalSessions}
  ‚Ä¢ Jeux jou√©s: ${totalGames}
  ‚Ä¢ Taux de r√©ussite: ${successRate}%
  ‚Ä¢ Questions r√©pondues: ${totalQuestions}
  ‚Ä¢ R√©ponses correctes: ${totalCorrect}

üéÆ R√âPARTITION PAR JEU
${Object.entries(gameBreakdown)
    .sort((a, b) => b[1] - a[1])
    .map(([game, count]) => `  ‚Ä¢ ${game}: ${count} sessions`)
    .join('\n') || '  Aucune activit√©'}

üìú HISTORIQUE R√âCENT (5 derni√®res sessions)
${sessions?.slice(0, 5).map(s => {
    const date = new Date(s.created_at).toLocaleDateString('fr-FR', { 
        day: 'numeric', 
        month: 'short',
        hour: '2-digit',
        minute: '2-digit'
    });
    const duration = s.duration_seconds ? Math.round(s.duration_seconds / 60) : 0;
    return `  ‚Ä¢ ${date}: ${s.game_type} (${s.category || 'Toutes cat√©gories'}) - ${duration}min`;
}).join('\n') || '  Aucune session'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            `.trim();

            // Create modal-like display
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 20px;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--white);
                padding: 30px;
                border-radius: 15px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;

            content.innerHTML = `
                <h2 style="color: var(--accent); margin-bottom: 20px;">D√©tails de l'utilisateur</h2>
                <pre style="white-space: pre-wrap; font-family: monospace; font-size: 0.9em; color: var(--text-primary); line-height: 1.6;">${details}</pre>
                <div style="margin-top: 20px; display: flex; gap: 10px;">
                    <button class="btn-danger" onclick="deleteUser('${userId}', '${user.username}'); this.closest('div[style*=fixed]').remove();" style="flex: 1;">üóëÔ∏è Supprimer</button>
                    <button class="btn-secondary" onclick="this.closest('div[style*=fixed]').remove();" style="flex: 1;">Fermer</button>
                </div>
            `;

            modal.appendChild(content);
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            document.body.appendChild(modal);
        }

        async function deleteVocabWord(wordId, korean) {
            if (!confirm(`‚ö†Ô∏è Supprimer le mot "${korean}" ?\n\nCette action est irr√©versible.`)) {
                return;
            }

            const { error } = await client
                .from('vocabulary')
                .delete()
                .eq('id', wordId);

            if (error) {
                alert('‚ùå Erreur: ' + error.message);
            } else {
                alert('‚úÖ Mot supprim√© avec succ√®s');
                loadAdminData();
                displayVocab();
                updateWordCounter();
            }
        }

        async function cleanInactiveUsers() {
            if (!confirm('‚ö†Ô∏è ATTENTION: Cela supprimera tous les utilisateurs qui n\'ont JAMAIS jou√© (0 sessions).\n\nContinuer ?')) {
                return;
            }

            // Get all users and sessions
            const { data: users } = await client.from('users').select('id, username');
            const { data: sessions } = await client.from('user_sessions').select('user_id');

            if (!users || !sessions) {
                alert('‚ùå Erreur de chargement des donn√©es');
                return;
            }

            // Find users with no sessions
            const activeUserIds = new Set(sessions.map(s => s.user_id));
            const inactiveUsers = users.filter(u => !activeUserIds.has(u.id));

            if (inactiveUsers.length === 0) {
                alert('‚ÑπÔ∏è Aucun utilisateur inactif √† supprimer');
                return;
            }

            if (!confirm(`Supprimer ${inactiveUsers.length} utilisateur(s) inactif(s) ?\n\n${inactiveUsers.map(u => u.username).join(', ')}`)) {
                return;
            }

            let deleted = 0;
            for (const user of inactiveUsers) {
                const { error } = await client.from('users').delete().eq('id', user.id);
                if (!error) deleted++;
            }

            alert(`‚úÖ ${deleted} utilisateur(s) inactif(s) supprim√©(s)`);
            loadAdminData();
        }

        function filterVocabByCategory() {
            // Cette fonction est maintenant appel√©e automatiquement lors du changement de s√©lection
            loadAdminData();
        }

        init();
    </script>
</body>
</html>
